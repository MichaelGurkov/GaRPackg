---
title: "Analysis"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Analysis}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

<style type="text/css">
  body{
  font-size: 14pt;
}
</style>


```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  echo = TRUE,
  comment = "#>", warning = FALSE, message = FALSE
)
```

This vignette demonstrates the use of the "workhorse" function of the package  - `run_GaR_analysis`.
This function takes the data, tranformes the variables (if required), performs dimension reduction (if required) and then runs quantile regression and returns several objects

First we'll load the package and import our dataset


```{r setup}

library(GaRPackg)

```

```{r import_process_data}

data("gar_data")


```


The required arguments for `run_GaR_analysis` are:

 - A list of groups of variables in order to perform dimension
 reduction (the default method is PCA).
 - A list of forecast horizons
 - A list of distribution quantiles.

Now we define those as parameters (in order to feed them to the function). For educational purposes two groups (each including two variables) are defined: 

 - Macro group that includes GDP and Industrial production index
 - Financial group that includes credit and house price variables. 
 
The forecasting will be done at one quarter and one year (four quarters) horizon with three quantiles (5%, 50%, 95%) estimated.

In this setting a more appropriate approach would be to transform the variables
(we'll you Year on Year transformation, for more details see [preprocessing vignette](preprocessing.html)). In order to reference the transformed
variables to the analysis function we'll add "_yoy" suffix to the names of the variables



```{r, echo=TRUE}

partitions_list = list(
  macro = c("gdp_yoy", "ind_prod_israel_yoy"),
  fin = c("credit_yoy", "house_price_yoy")
)

horizon_list = c(1,4)

quantile_vec = c(0.05,0.5,0.95)

```


```{r run_analysis}

result = run_GaR_analysis(
  partitions_list = partitions_list,
  vars_df = gar_data,
  target_var_name = "gdp_yoy",
  horizon_list = horizon_list,
  quantile_vec = quantile_vec
)

```


`run_GaR_analysis` returns several useful objects that can be used
to evaluate and investigate results. The returned objects are:

 - Data frame with quantile regression data (`reg_df`)
 - Quantile regression model results for each horizon (`qreg_result`)
 - Fitted values for each regression (`fitted_df`)
 - List of feature groups (partitions) (`partitions_list`)
 - List of PCA objects including components and loadings (`pca_obj`)

```{r print_results}
names(result)
```

## Internal vs explicit preprocessing

The preprocessing is performed by default by \code{run_GaR_analysis} based on partition list variable names suffixes. However in case we want to perform the
preprocessing explicitly (for instance in order to take a look at preprocessed variables) we can do that and then pass the preprocessed data to \code{run_GaR_analysis}. Let's demonstrate both ways and make sure that they give the same result

The internal (implicit) preprocessing was already performed in the previous example' the results are stored in \code{result} object. Now, let's perform an explicit preprocessing
and compare the result. Note that we need to set the \code{transform_vars_df} flag in \code{run_GaR_analysis} to \code{FALSE} since we have already transformed the data

```{r preprocess_data}

preprocess_data = preprocess_df(df = gar_data,
                                partitions_list = partitions_list)

explicit_preprocessing_result = run_GaR_analysis(
  partitions_list = partitions_list,
  vars_df = preprocess_data,
  target_var_name = "gdp_yoy",
  horizon_list = horizon_list,
  quantile_vec = quantile_vec,
  transform_vars_df = FALSE
)

all.equal(result, explicit_preprocessing_result)

```

